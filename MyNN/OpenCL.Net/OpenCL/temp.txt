
int ComputeWeightIndex(
    int previousLayerNeuronCount,
    int neuronIndex)
{
    return
        previousLayerNeuronCount * neuronIndex;
}

//const __constant float _alpha = 0.2;
//const __constant float _beta = 1.0;

__kernel void HiddenLayerTrain(
    __global float * previousLayerLastState,
    __global float * currentLayerLastState,
    __global float * currentLayerDeDz,
    __global float * nextLayerDeDz,

    __global float * currentLayerWeights,
    __global float * nextLayerWeights,
            
    __global float * nabla,

    __global uint * mask,

    int previousLayerNeuronCount4,
    int previousLayerNeuronCount4M4,
    int previousLayerNeuronCount,
    int currentLayerNeuronCount,
    int nextLayerNeuronCount,

    float learningRate,
    float regularizationFactor,
    float dataCount,

    uint bitmask)
{
    int neuronIndex = get_global_id(0);

    int currentNablaIndex = ComputeWeightIndex(previousLayerNeuronCount, neuronIndex);

    //просчет состояния нейронов текущего слоя, по состоянию нейронов последующего
    float currentDeDz = 0;
    for (int nextNeuronIndex = 0; nextNeuronIndex < nextLayerNeuronCount; ++nextNeuronIndex)
    {
        int nextWeightIndex = ComputeWeightIndex(currentLayerNeuronCount + 1, nextNeuronIndex) + neuronIndex; //не векторизуется:(

        float nextWeight = nextLayerWeights[nextWeightIndex];
        float nextNabla = nextLayerDeDz[nextNeuronIndex];
        float multiplied = nextWeight * nextNabla;

        currentDeDz += multiplied;
    }

    float nOut = currentLayerLastState[neuronIndex];
    currentDeDz *= 
(1.7159 * (
    0.6666 
    - pow(0.6666, 3) * pown(nOut, 2)
    + 2.0f * pow(0.6666, 5) * pown(nOut, 4) / 3.0f
    - 17.0f * pow(0.6666, 7) * pown(nOut, 6) / 45.0f
    )
);//nOut * (1 - nOut);
    currentLayerDeDz[neuronIndex] = currentDeDz;

    int currentNablaIndex4 = currentNablaIndex / 4;
    int currentNablaIndex4Shift = currentNablaIndex - currentNablaIndex4 * 4;

    //просчет изменений в весах нейронов текущего слоя по состоянию нейронов предыдущего
    //векторизованная часть
    for (
        int currentWeightIndex4 = 0; 
        currentWeightIndex4 < previousLayerNeuronCount4; 
        ++currentWeightIndex4)
    {
        float4 prevOut = vload4(currentWeightIndex4, previousLayerLastState);

        float4 regularizationCoef = 0;
        float4 coef = prevOut + regularizationCoef;

        uint4 mask4i = vload4(currentNablaIndex4 + currentWeightIndex4, mask + currentNablaIndex4Shift);
        float4 mask4 = convert_float4(((mask4i & bitmask) > 0) ? 1 : 0);

        float4 n = learningRate * mask4 * currentDeDz * coef;

        
        float4 nabla4 = vload4(currentNablaIndex4 + currentWeightIndex4, nabla + currentNablaIndex4Shift);
        n += nabla4;


        vstore4(
            n,
            currentNablaIndex4 + currentWeightIndex4,
            nabla + currentNablaIndex4Shift);
    }

    //невекторизованная часть (добиваем остатки)
    for (
        int currentWeightIndex = previousLayerNeuronCount4M4; 
        currentWeightIndex < previousLayerNeuronCount; 
        ++currentWeightIndex)
    {
        float prevOut = previousLayerLastState[currentWeightIndex];

        float regularizationCoef = 0;
        float coef = prevOut + regularizationCoef;

        uint mask1i = mask[currentNablaIndex + currentWeightIndex];
        float mask1 = ((mask1i & bitmask) > 0) ? (float)1 : (float)0;

        float n = learningRate * mask1 * currentDeDz * coef;

        
        nabla[currentNablaIndex + currentWeightIndex] += n;

    }
}

__kernel void OutputLayerTrain(
    __global float * previousLayerLastState,
    __global float * currentLayerLastState,
    __global float * currentLayerDeDz,

    __global float * desiredOutput,

    __global float * currentLayerWeights,
            
    __global float * nabla,

    __global uint * mask,

    int previousLayerNeuronCount4,
    int previousLayerNeuronCount4M4,
    int previousLayerNeuronCountTotal,
    int currentLayerNeuronCount,

    float learningRate,
    float regularizationFactor,
    float dataCount,

    uint bitmask)
{
    int neuronIndex = get_global_id(0);

    float nOut = currentLayerLastState[neuronIndex];

    float n =
        
(1.7159 * (
    0.6666 
    - pow(0.6666, 3) * pown(nOut, 2)
    + 2.0f * pow(0.6666, 5) * pown(nOut, 4) / 3.0f
    - 17.0f * pow(0.6666, 7) * pown(nOut, 6) / 45.0f
    )
) //rOut * (1 - nOut)
        * (desiredOutput[neuronIndex] - nOut);

    currentLayerDeDz[neuronIndex] = n;

    int nablaNeuronShift = ComputeWeightIndex(previousLayerNeuronCountTotal, neuronIndex);
    int nablaNeuronShift4 = nablaNeuronShift / 4;
    int nablaNeuronShift4Shift = nablaNeuronShift - nablaNeuronShift4 * 4;

    //векторизованная часть
    for (
        int weightIndex4 = 0;
        weightIndex4 < previousLayerNeuronCount4;
        ++weightIndex4)
    {
        float4 previousLayerLastState4 = vload4(weightIndex4, previousLayerLastState);
        float4 currentLayerWeights4 = vload4(nablaNeuronShift4 + weightIndex4, currentLayerWeights + nablaNeuronShift4Shift);

        uint4 mask4i = vload4(nablaNeuronShift4 + weightIndex4, mask + nablaNeuronShift4Shift);
        float4 mask4 = ((mask4i & bitmask) > 0) ? (float)1 : (float)0;

        float4 deltaWeight4 = 
            learningRate *
            n *
            mask4 *
            (previousLayerLastState4 + 0);

        
        float4 nabla4 = vload4(nablaNeuronShift4 + weightIndex4, nabla + nablaNeuronShift4Shift);
        deltaWeight4 += nabla4;


        vstore4(
            deltaWeight4,
            nablaNeuronShift4 + weightIndex4,
            nabla + nablaNeuronShift4Shift);
    }

    //добираем остатки (от нуля до 3 флоатов)
    for (
        int weightIndex = previousLayerNeuronCount4M4; 
        weightIndex < previousLayerNeuronCountTotal; 
        ++weightIndex)
    {
        uint mask1i = mask[nablaNeuronShift + weightIndex];
        float mask1 = ((mask1i & bitmask) > 0) ? (float)1 : (float)0;

        float deltaWeight =
            learningRate *
            n *
            mask1 *
            (previousLayerLastState[weightIndex] + 0);

        
        nabla[nablaNeuronShift + weightIndex] += deltaWeight;

    }
}
